/**
 * @vue/reactivity v3.4.21
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
'use strict';

Object.defineProperty(exports, '__esModule', {value: true});

var shared = require('@vue/shared');
const {watchEffect} = require("vue");

function warn(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}

let activeEffectScope;

class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    /**
     * @internal
     */
    this._active = true;
    /**
     * @internal
     */
    this.effects = [];
    /**
     * @internal
     */
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
          this
      ) - 1;
    }
  }

  get active() {
    return this._active;
  }

  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else {
      warn(`cannot run an inactive effect scope.`);
    }
  }

  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }

  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }

  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}

function effectScope(detached) {
  return new EffectScope(detached);
}

function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}

function getCurrentScope() {
  return activeEffectScope;
}

function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  } else {
    warn(
        `onScopeDispose() is called when there is no active effect scope to be associated with.`
    );
  }
}

// 笔记13-2
// effect在vue3中称为副作用，作用与vue2的watcher是类似的，
let activeEffect;
// 创建全局的activeEffect，默认位undefined

// 笔记14 effect类相当于vue2的watcher
class ReactiveEffect {
  constructor(fn, trigger, scheduler, scope) {
    this.fn = fn;
    // 回调函数fn，和watcher实例中的fn一样，最终都是为了执行这个回调函数

    this.trigger = trigger;
    // trigger触发更新

    this.scheduler = scheduler;
    // scheduler调度程序，*调度函数决定了如何执行fn

    this.active = true;
    this.deps = [];
    /**
     * @internal
     */
    this._dirtyLevel = 4;
    /**
     * @internal
     */
    this._trackId = 0;
    /**
     * @internal
     */
    this._runnings = 0;
    /**
     * @internal
     */
    this._shouldSchedule = false;
    /**
     * @internal
     */
    this._depsLength = 0;
    recordEffectScope(this, scope);
    // 记录effect作用域

  }

  get dirty() {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      this._dirtyLevel = 1;
      pauseTracking();
      for (let i = 0; i < this._depsLength; i++) {
        const dep = this.deps[i];
        if (dep.computed) {
          triggerComputed(dep.computed);
          if (this._dirtyLevel >= 4) {
            break;
          }
        }
      }
      if (this._dirtyLevel === 1) {
        this._dirtyLevel = 0;
      }
      resetTracking();
    }
    return this._dirtyLevel >= 4;
  }

  set dirty(v) {
    this._dirtyLevel = v ? 4 : 0;
  }

  run() {
    // 执行回调函数fn，返回值为fn的执行结果

    this._dirtyLevel = 0;
    if (!this.active) {
      return this.fn();
    }
    let lastShouldTrack = shouldTrack;
    let lastEffect = activeEffect;
    try {
      shouldTrack = true;
      activeEffect = this;
      this._runnings++;
      preCleanupEffect(this);
      return this.fn();
    } finally {
      postCleanupEffect(this);
      this._runnings--;
      activeEffect = lastEffect;
      shouldTrack = lastShouldTrack;
    }
  }

  stop() {
    var _a;
    if (this.active) {
      preCleanupEffect(this);
      postCleanupEffect(this);
      (_a = this.onStop) == null ? void 0 : _a.call(this);
      this.active = false;
    }
  }
}

// 笔记15
/*ReactiveEffect类和vue2中的watcher类非常相似，ReactiveEffect类生成effect实例，effect实例收集dep实例，
dep实例收集effect实例。
activeEffect在run函数中被赋值，只有run函数被调用，activeEffect才会被赋值，ref数据的trackEffect才会执行
收集逻辑，
组件在创建renderEffect实例之前，会先调用setup函数完成组件初始化。vue3的响应式数据都是在setup调用过程初始化
的，包括计算属性以及watch，所以在renderEffect创建之前，组件中的ref，reactive，computed,watch就已经完成
初始化。
首先ref/reactive一定是最开始初始化的，因为computed以及watch一般都需要依赖于响应式数据，所以我们的computed
以及watch一般都会定义在响应式数据之后，所以ref/reactive在初始化创建完成之时，是没有收集任何以来的，因为还没有
被引用，不会触发get拦截处理

在vue3中，只有三种类型的依赖即effect实例，computedEffect，watchEffect，renderEffect(render函数，可理解
为template)，所以ref/reactive响应式数据只有被computed、watch、template模版中被引用了才能收集到对应的依赖。
在computed和watch初始化过程中，如果引用了ref/reactive数据，那么这时候ref/reactive就能收集到对应的computed
和watchEffect实例

#案例
const str = ref({age:1});
const countTxt = computed(()={
  return str.value.age++
})
function fnTest (){
  console.log('countTxt',countTxt.value)
}
fnTest()
1.调用fnTest，触发context实例get，contTxt收集自身computedEffect
2.computed 调用getter，就会触发str的get，str就能收集到computedEffect

computed(): getter内部引用了一个ref数据，然后在computed实例初始化时，内部创建computedEffect，同时将effect
实例存储盗了computed自身的effect属性上，计算属性虽然被创建了，但是没有被访问，所有没有执行一次getter，也不会触发
ref数据的get，也就收集不到computedEffect，而计算属性被访问两种情况，1.后续的函数调用中被访问（包含watch的回调
函数调用，watch的回调函数中可以使用计算属性值）。2.在组件渲染时的模版中访问，以前面的情况为例，这时计算属性被访问
了，就会执行以此effect.run（），在run（）函数中会将当前的computedEffect实例赋值给activeEffect。这时activeEffect
有了值，run()函数中还会调用fn回调函数，在这里就是getter()，所以也就会触发ref的get拦截操作，ref数据收集依赖的两个
变量条件都已经满足，也就能够继续触发后续的收集逻辑，（也就是收集这个computedEffect实例）

#案例
const str = ref({age:1})
const countTxt = computed(()=>{
  return str.value.age += 1
})
function fnTests (){
  console.log(countTxt.value)
}
fnTests()
watch(()=>{
  str.value.age,(val)=>{
    // 初始化最后，执行getter ，即()=>str.value.age,就会触发ref数据的get，即可以收集watchEffect依赖

    console.log(val)
  }
})
// dep是一个set结构，可对内容自动去重，不会存在重复收集*/


function triggerComputed(computed) {
  return computed.value;
}

function preCleanupEffect(effect2) {
  effect2._trackId++;
  effect2._depsLength = 0;
}

function postCleanupEffect(effect2) {
  if (effect2.deps.length > effect2._depsLength) {
    for (let i = effect2._depsLength; i < effect2.deps.length; i++) {
      cleanupDepEffect(effect2.deps[i], effect2);
    }
    effect2.deps.length = effect2._depsLength;
  }
}

function cleanupDepEffect(dep, effect2) {
  const trackId = dep.get(effect2);
  if (trackId !== void 0 && effect2._trackId !== trackId) {
    dep.delete(effect2);
    if (dep.size === 0) {
      dep.cleanup();
    }
  }
}

function effect(fn, options) {
  if (fn.effect instanceof ReactiveEffect) {
    fn = fn.effect.fn;
  }
  const _effect = new ReactiveEffect(fn, shared.NOOP, () => {
    if (_effect.dirty) {
      _effect.run();
    }
  });
  if (options) {
    shared.extend(_effect, options);
    if (options.scope)
      recordEffectScope(_effect, options.scope);
  }
  if (!options || !options.lazy) {
    _effect.run();
  }
  const runner = _effect.run.bind(_effect);
  runner.effect = _effect;
  return runner;
}

function stop(runner) {
  runner.effect.stop();
}

// 笔记13-1
let shouldTrack = true;
// 默认需要收集

let pauseScheduleStack = 0;
const trackStack = [];

function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}

function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}

function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}

function pauseScheduling() {
  pauseScheduleStack++;
}

function resetScheduling() {
  pauseScheduleStack--;
  while (!pauseScheduleStack && queueEffectSchedulers.length) {
    queueEffectSchedulers.shift()();
  }
}

// 笔记15
function trackEffect(effect2, dep, debuggerEventExtraInfo) {
  // 默认不收集

  var _a;
  if (dep.get(effect2) !== effect2._trackId) {
    dep.set(effect2, effect2._trackId);
    const oldDep = effect2.deps[effect2._depsLength];
    if (oldDep !== dep) {
      if (oldDep) {
        cleanupDepEffect(oldDep, effect2);
      }
      effect2.deps[effect2._depsLength++] = dep;
    } else {
      effect2._depsLength++;
    }
    {
      (_a = effect2.onTrack) == null ? void 0 : _a.call(effect2, shared.extend({effect: effect2}, debuggerEventExtraInfo));
    }
  }
}

const queueEffectSchedulers = [];

function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
  var _a;
  pauseScheduling();
  for (const effect2 of dep.keys()) {
    let tracking;
    if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
      effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
      effect2._dirtyLevel = dirtyLevel;
    }
    if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
      {
        (_a = effect2.onTrigger) == null ? void 0 : _a.call(effect2, shared.extend({effect: effect2}, debuggerEventExtraInfo));
      }
      effect2.trigger();
      if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
        effect2._shouldSchedule = false;
        if (effect2.scheduler) {
          queueEffectSchedulers.push(effect2.scheduler);
        }
      }
    }
  }
  resetScheduling();
}

// 笔记11
const createDep = (cleanup, computed) => {
  const dep = /* @__PURE__ */ new Map();
  dep.cleanup = cleanup;
  dep.computed = computed;
  return dep;
  // 创建dep实例依赖容器
  // dep是专门用来收集effect实例的容器
  // 目的是在响应式数据变化的时候，执行effect实例中的回调函数
};

const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol("iterate");
const MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");

function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
    }
    trackEffect(
        activeEffect,
        dep,
        {
          target,
          type,
          key
        }
    );
  }
}

function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && shared.isArray(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || !shared.isSymbol(key2) && key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!shared.isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (shared.isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (shared.isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!shared.isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (shared.isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (shared.isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  pauseScheduling();
  for (const dep of deps) {
    if (dep) {
      triggerEffects(
          dep,
          4,
          {
            target,
            type,
            key,
            newValue,
            oldValue,
            oldTarget
          }
      );
    }
  }
  resetScheduling();
}

function getDepFromReactive(object, key) {
  var _a;
  return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);
}

const isNonTrackableKeys = /* @__PURE__ */ shared.makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(shared.isSymbol)
);

// 笔记10标记处1
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();

// 笔记10
function createArrayInstrumentations() {
  const instrumentations = {};
  // 此处重写了3个方法，includes.indexOf,lastIndexOf

  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function (...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });

  // 此处重写了5个方法，push,pop,shift,unshift,splice
  // 所以用这几个方法的时候，是可以响应式的改变原数组的

  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function (...args) {
      pauseTracking();
      pauseScheduling();
      const res = toRaw(this)[key].apply(this, args);
      resetScheduling();
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}

function hasOwnProperty(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}

// 笔记9-1
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }

  get(target, key, receiver) {
    // 在获取属性值的操作中被调用

    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
          // this means the reciever is a user proxy of the reactive proxy
          Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    // 如果获取到的为reactive响应式对象，readonly只读，isShallow浅层则直接返回

    const targetIsArray = shared.isArray(target);
    // 判断目标是否为array数组

    if (!isReadonly2) {
      if (targetIsArray && shared.hasOwn(arrayInstrumentations, key)) {
        // 如果是数组，并且key为数组的操作api，则进行拦截，重写对应的操作方法，并且加入依赖收集
        // 详情见笔记10

        return Reflect.get(arrayInstrumentations, key, receiver);
        // 返回数组api读取的结果res，*核心

      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }

    const res = Reflect.get(target, key, receiver);
    // 常规obj/arr的key读取

    if (shared.isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    // 增加判断，如果key类型是symbol

    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
      // 如果是浅层响应式，则直接返回res

    }
    if (isRef(res)) {
      return targetIsArray && shared.isIntegerKey(key) ? res : res.value;
      // 如果读取的是ref类型的数据，如果是array数组并且key为Integer整数即索引，则直接返回res，否则返回ref.value

    }
    if (shared.isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
    // 上述都不符合，读取的结果是一个原始值，直接返回

  }
}

// 笔记9-2
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }

  set(target, key, value, receiver) {
    let oldValue = target[key];
    // 保存旧值

    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      // 判断旧值是否为只读

      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!shared.isArray(target) && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = shared.isArray(target) && shared.isIntegerKey(key) ? Number(key) < target.length : shared.hasOwn(target, key);
    // 判断target目标是否为数组并且key是否为IntegerKey整数即索引。
    // Number(key) < target.length 为布尔
    // shared.hasOwn(target, key) 为布尔 （shared.hasOwn方法，判断对象是否含有某个属性）
    // 数组情况，key小于length说明在数组中存在

    const result = Reflect.set(target, key, value, receiver);
    // 常规key的value设置 *核心Reflect.set

    if (target === toRaw(receiver)) {
      // 判断receiver 必须是target的代理对象才触发更新，如果在原型链上则不触发，避免浪费性能
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (shared.hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
      // add新增以及set修改，都会触发依赖（即dep依赖容器中收集的effect实例）

    }
    return result;
    // 返回true则表示设置成改，返回false则失败

  }

  // 笔记9-3
  deleteProperty(target, key) {
    // delete操作，删除一个属性key
    const hadKey = shared.hasOwn(target, key);
    // shared.hasOwn检验target是否含有属性key

    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    // *核心api：Reflect.deleteProperty ，删除成功返回true

    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
      // 触发依赖

    }
    return result;
  }

  // 笔记9-4
  has(target, key) {
    const result = Reflect.has(target, key);
    // 判断obj中有无属性key

    if (!shared.isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
      // 收集依赖

    }
    return result;
  }

  // 笔记9-5
  ownKeys(target) {
    track(
        target,
        "iterate",
        shared.isArray(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}

class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }

  set(target, key) {
    {
      warn(
          `Set operation on key "${String(key)}" failed: target is readonly.`,
          target
      );
    }
    return true;
  }

  deleteProperty(target, key) {
    {
      warn(
          `Delete operation on key "${String(key)}" failed: target is readonly.`,
          target
      );
    }
    return true;
  }
}

const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
    true
);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);

const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);

function get(target, key, isReadonly = false, isShallow = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly) {
    if (shared.hasChanged(key, rawKey)) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const {has: has2} = getProto(rawTarget);
  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}

function has(key, isReadonly = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly) {
    if (shared.hasChanged(key, rawKey)) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}

function size(target, isReadonly = false) {
  target = target["__v_raw"];
  !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}

function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}

function set(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const {has: has2, get: get2} = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (shared.hasChanged(value, oldValue)) {
    trigger(target, "set", key, value, oldValue);
  }
  return this;
}

function deleteEntry(key) {
  const target = toRaw(this);
  const {has: has2, get: get2} = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}

function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget = shared.isMap(target) ? new Map(target) : new Set(target);
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}

function createForEach(isReadonly, isShallow) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}

function createIterableMethod(method, isReadonly, isShallow) {
  return function (...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = shared.isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(
        rawTarget,
        "iterate",
        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const {value, done} = innerIterator.next();
        return done ? {value, done} : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}

function createReadonlyMethod(type) {
  return function (...args) {
    {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      warn(
          `${shared.capitalize(type)} operation ${key}failed: target is readonly.`,
          toRaw(this)
      );
    }
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}

function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(
        method,
        false,
        false
    );
    readonlyInstrumentations2[method] = createIterableMethod(
        method,
        true,
        false
    );
    shallowInstrumentations2[method] = createIterableMethod(
        method,
        false,
        true
    );
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
        method,
        true,
        true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}

const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();

function createInstrumentationGetter(isReadonly, shallow) {
  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly;
    } else if (key === "__v_isReadonly") {
      return isReadonly;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
        shared.hasOwn(instrumentations, key) && key in target ? instrumentations : target,
        key,
        receiver
    );
  };
}

const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};

function checkIdentityKeys(target, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target, rawKey)) {
    const type = shared.toRawType(target);
    warn(
        `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}

const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();

function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1 /* COMMON */;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2 /* COLLECTION */;
    default:
      return 0 /* INVALID */;
  }
}

function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(shared.toRawType(value));
}

// 笔记7
function reactive(target) {
  if (isReadonly(target)) {
    return target;
    // readonly只读数据则直接返回

  }

  return createReactiveObject(
      target,
      false,
      mutableHandlers,
      mutableCollectionHandlers,
      reactiveMap
  );
  // 创建响应式数据

}

function shallowReactive(target) {
  return createReactiveObject(
      target,
      false,
      shallowReactiveHandlers,
      shallowCollectionHandlers,
      shallowReactiveMap
  );
}

function readonly(target) {
  return createReactiveObject(
      target,
      true,
      readonlyHandlers,
      readonlyCollectionHandlers,
      readonlyMap
  );
}

function shallowReadonly(target) {
  return createReactiveObject(
      target,
      true,
      shallowReadonlyHandlers,
      shallowReadonlyCollectionHandlers,
      shallowReadonlyMap
  );
}

// 笔记8
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  //

  if (!shared.isObject(target)) {
    {
      warn(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
    // 如果target不是object对象，则直接返回
  }

  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
    // 如果目标是非只读并且已经被proxy代理，则直接返回
  }

  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  // existing：现有的
  // 如果目标存在对应的proxy代理对象，则直接返回对应的proxy

  const targetType = getTargetType(target);
  // 获得传入target的类型，基本类型视为无效类型

  if (targetType === 0 /* INVALID */) {
    // 如果目标为无效类型，则直接返回，不会进行响应式转换

    return target;
  }

  const proxy = new Proxy(
      // 新建proxy对象

      target,
      targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers
      // collectionHandlers：map/set
      // baseHandlers：obj/list
      // 判断传入target是否是map，set类型，传入不同的handlers处理对象
      /*  baseHandlers是处理程序对象，创建proxy的核心，内置5个捕获器，
          get，set，deleteProperty，has，ownKeys，即增删改查操作，详情见笔记9  */
  );
  proxyMap.set(target, proxy);
  // 在map结构里，添加一对键值，存储目标与代理，防止重复新建

  return proxy;
  // 返回的proxy代理对象即为响应式数据

}

/*reactive 方法只能对对象类型进行代理转换，如果传入原始类型，则不会有任何操作并报warn,
在创建proxy代理对象前，还做了优化校验，比如proxymap变量是map结构，存储的键值是对应的
target与proxy，每次新建都会存入一对键值，而在新建之前可以在这个map结构中查询是否已经存在
对应的proxy，如果存在就不在重复创建*/

function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}

function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}

function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}

function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}

function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}

function markRaw(value) {
  if (Object.isExtensible(value)) {
    shared.def(value, "__v_skip", true);
  }
  return value;
}

// 笔记6
const toReactive = (value) => shared.isObject(value) ? reactive(value) : value;
// 使用ref创建响应式，如果传入了object对象类参数，就会使用reactive方法生成proxy响应式代理对象

const toReadonly = (value) => shared.isObject(value) ? readonly(value) : value;

const COMPUTED_SIDE_EFFECT_WARN = `Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free`;

class ComputedRefImpl {
  constructor(getter, _setter, isReadonly, isSSR) {
    this.getter = getter;
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this.effect = new ReactiveEffect(
        () => getter(this._value),
        () => triggerRefValue(
            this,
            this.effect._dirtyLevel === 2 ? 2 : 3
        )
    );
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly;
  }

  get value() {
    const self = toRaw(this);
    if ((!self._cacheable || self.effect.dirty) && shared.hasChanged(self._value, self._value = self.effect.run())) {
      triggerRefValue(self, 4);
    }
    trackRefValue(self);
    if (self.effect._dirtyLevel >= 2) {
      if (this._warnRecursive) {
        warn(COMPUTED_SIDE_EFFECT_WARN, `

getter: `, this.getter);
      }
      triggerRefValue(self, 2);
    }
    return self._value;
  }

  set value(newValue) {
    this._setter(newValue);
  }

  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
  get _dirty() {
    return this.effect.dirty;
  }

  set _dirty(v) {
    this.effect.dirty = v;
  }

  // #endregion
}

function computed(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = shared.isFunction(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = () => {
      warn("Write operation failed: computed value is readonly");
    };
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  if (debugOptions && !isSSR) {
    cRef.effect.onTrack = debugOptions.onTrack;
    cRef.effect.onTrigger = debugOptions.onTrigger;
  }
  return cRef;
}

// 笔记13-3
function trackRefValue(ref2) {
  var _a;
  if (shouldTrack && activeEffect) {
    // 判断activeEffect为undefined时无法执行，此时去查看activeEffect为undefined赋值

    ref2 = toRaw(ref2);
    trackEffect(
        activeEffect,
        (_a = ref2.dep) != null ? _a : ref2.dep = createDep(
            // createDep创建dep实例，用于收集依赖

            () => ref2.dep = void 0,
            // 初始ref2.dep为undefined，第一次收集依赖，初始化ref.dep为集合对象
            ref2 instanceof ComputedRefImpl ? ref2 : void 0
        ),
        {
          target: ref2,
          type: "get",
          key: "value"
        }
    );
  }
}

function triggerRefValue(ref2, dirtyLevel = 4, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    triggerEffects(
        dep,
        dirtyLevel,
        {
          target: ref2,
          type: "set",
          key: "value",
          newValue: newVal
        }
    );
  }
}

function isRef(r) {
  return !!(r && r.__v_isRef === true);
}

// 笔记1
function ref(value) {
  return createRef(value, false);
  // 定义响应式数据api
}

function shallowRef(value) {
  return createRef(value, true);
}

// 笔记2
function createRef(rawValue, shallow) {

  if (isRef(rawValue)) {
    return rawValue;
  }
  // isRef判断如果传入的数据已经是ref数据，则直接返回，

  return new RefImpl(rawValue, shallow);
  // 否侧，新建一个ref实例，并返回
}

// 笔记3
class RefImpl {
  constructor(value, __v_isShallow) {
    // 初始化两个私有属性值，

    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    // 原value值

    this._value = __v_isShallow ? value : toReactive(value);
    // 新value值，不是浅层的就转化为深层响应式数据

  }

  // 笔记4
  get value() {
    trackRefValue(this);
    // 收集依赖

    return this._value;
    // ref类：定义一个访问器value属性，获取value返回this._value

  }

  // 笔记5
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    // 判断是否为浅层/只读

    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (shared.hasChanged(newVal, this._rawValue)) {
      // 判断值是否发生更新

      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      // 如果只是浅层/只读，就不会进行深层响应式创建(数据类型的判断在toReactive方法里面)

      triggerRefValue(this, 4, newVal);
      // 触发依赖

    }
  }
}

// ref创建响应式数据，如果传入的是原始类型数据，则直接赋值，如果是引用类型数据，则需要通过reactive
// 方法创建proxy代理对象再赋值。


function triggerRef(ref2) {
  triggerRefValue(ref2, 4, ref2.value);
}

function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}

function toValue(source) {
  return shared.isFunction(source) ? source() : unref(source);
}

const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};

function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}

class CustomRefImpl {
  constructor(factory) {
    this.dep = void 0;
    this.__v_isRef = true;
    const {get, set} = factory(
        () => trackRefValue(this),
        () => triggerRefValue(this)
    );
    this._get = get;
    this._set = set;
  }

  get value() {
    return this._get();
  }

  set value(newVal) {
    this._set(newVal);
  }
}

function customRef(factory) {
  return new CustomRefImpl(factory);
}

function toRefs(object) {
  if (!isProxy(object)) {
    warn(`toRefs() expects a reactive object but received a plain one.`);
  }
  const ret = shared.isArray(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}

class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }

  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }

  set value(newVal) {
    this._object[this._key] = newVal;
  }

  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}

class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this.__v_isRef = true;
    this.__v_isReadonly = true;
  }

  get value() {
    return this._getter();
  }
}

function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if (shared.isFunction(source)) {
    return new GetterRefImpl(source);
  } else if (shared.isObject(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}

function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}

const deferredComputed = computed;

const TrackOpTypes = {
  "GET": "get",
  "HAS": "has",
  "ITERATE": "iterate"
};
const TriggerOpTypes = {
  "SET": "set",
  "ADD": "add",
  "DELETE": "delete",
  "CLEAR": "clear"
};
const ReactiveFlags = {
  "SKIP": "__v_skip",
  "IS_REACTIVE": "__v_isReactive",
  "IS_READONLY": "__v_isReadonly",
  "IS_SHALLOW": "__v_isShallow",
  "RAW": "__v_raw"
};

exports.EffectScope = EffectScope;
exports.ITERATE_KEY = ITERATE_KEY;
exports.ReactiveEffect = ReactiveEffect;
exports.ReactiveFlags = ReactiveFlags;
exports.TrackOpTypes = TrackOpTypes;
exports.TriggerOpTypes = TriggerOpTypes;
exports.computed = computed;
exports.customRef = customRef;
exports.deferredComputed = deferredComputed;
exports.effect = effect;
exports.effectScope = effectScope;
exports.enableTracking = enableTracking;
exports.getCurrentScope = getCurrentScope;
exports.isProxy = isProxy;
exports.isReactive = isReactive;
exports.isReadonly = isReadonly;
exports.isRef = isRef;
exports.isShallow = isShallow;
exports.markRaw = markRaw;
exports.onScopeDispose = onScopeDispose;
exports.pauseScheduling = pauseScheduling;
exports.pauseTracking = pauseTracking;
exports.proxyRefs = proxyRefs;
exports.reactive = reactive;
exports.readonly = readonly;
exports.ref = ref;
exports.resetScheduling = resetScheduling;
exports.resetTracking = resetTracking;
exports.shallowReactive = shallowReactive;
exports.shallowReadonly = shallowReadonly;
exports.shallowRef = shallowRef;
exports.stop = stop;
exports.toRaw = toRaw;
exports.toRef = toRef;
exports.toRefs = toRefs;
exports.toValue = toValue;
exports.track = track;
exports.trigger = trigger;
exports.triggerRef = triggerRef;
exports.unref = unref;
